https://www.youtube.com/watch?v=SzV4l0_1MCQ
https://www.cs.ubc.ca/~feeley/cs213/2011w1/resources/companion.pdf (Ch 1, 2.1)

Combination Circuits - Where an output is based ONLY on a present input. Combination circuit uses static information.

Sequential Circuits - Where an output is based on both an present input AND a previous output. Because there is a previous output, memory is needed to store that previous output. Sequential Circuits uses dynamic information. The input comes from a register. The output comes out to the same register. 

There is also a third input, called F. F is a number that selects one of several functions. For example F= 4 could mean A + B. F = 3 could mean A * B.

Clock - Determines when a circuit executes. Clocks have ticks (usually the rising edge) that goes from low to high repeatedly at a frequency. There are many signals/inputs that goes to the circuit. We don't want these signals/inputs to be executed randomly. The clock regulates that to ensure there is order and sequence to these signals/inputs.  

Memory - Short term storage. Data is wiped when computer shuts off (eg. RAM). Memory can be thought of as a long tape of bytes. Each byte has an address. The address is just an integer (eg. 132)

Storage - Persistent storage of data that exists even after computer is turned off (eg. writing on discs, hard drive, SSDs)

---

Bit is a 1 or 0. Every integers (eg. 1, 238, -71, etc) can be represented by 32 bits.

Bytes is 8 bits. Since it takes 32 bits to represent an integer and it takes 8 bits to represent a byte. An integer also represents 4 bytes. 

Array of Integers - if you have an array of length 3, you basically need 3 bytes stored in memory. 

Converting Integers to Binary

Hexadecimal starts with 0x. Hexadecimal is a base 16 system. You can represent 2 bytes with a hexadecimal 

When storing hexadecimal on the "memory tape" you can do it "left to right" or "right to left" as long as it is consistently like that in the computer it's acceptable. However when communicating data over a network, then there might be inconsistencies. 

Endianess: How do we store hexadecimals in a 8 bit system? Left to right (big endian) or right to left (little endian)? 

The RAM contains addresses. Each address is a byte (or 8 bits). The first 4 bits are the instructions (eg. math, load value, jump, halt, etc). 

The control unit fetches Address 0 of the memory. The memory at Address 0 is a byte. The first 4 bits are instructions, the last 4 bits are values. The control unit then decodes the instructions where the instructions can be add, subtract, load, etc. If the instruction is to load a value at Address x, the control unit takes action to do this, it reads Address x then loads it to register 1. The control unit might do the same thing to fetch instructions, read a value from Address Y, then loads that value to register 2. The control unit might then send an opcode (for example add) to the ALU. The ALU then takes the 3 inputs from register 1, register 2, the opcode and then outputs a value. The value might then be written to a memory at Address Z.


---

Arithmetic and Logic Unit (ALU) - has 2 inputs, an operation code, an output (with a destination), and an immediate value (aka the value that is not currently in the register). 

A sequential circuit is basically an ALU + register?

--- 

Variables are either static or dynamic. The compiler is aware of a static variables' address. Scalars (primities) and arrays also have a fixed address. The compiler does not know the address of a dynamic array. For static variable, once it is allocated, it cannot be changed. Dynamic variables have an initial amount of memory allocated that may grow or shrink. Dynamic allocation of memory is when the memory requirement is known only at run time. 

The programmer is the one who decides whether best to use static or dynamic variables. 

Example of static variable: int b = 5
Example of static array: int arr[] = new int[5] 
(array is always length 5 and will always occupy the same amount of memory blocks.
Example of dynamic variable: anything that uses malloc()

A static variable in Java belongs to a class, not to an object. All objects however "share" the static variable. In C it is called a "global scope". A static variable is written to an address that does not change, making it easy to retrieve as the compiler knows the location. If a variable is a reference, it complicates things as multiple steps are needed to retrieve the value of a variable that uses a reference. 

The compiler basically converts high level language to machine code. 

In C, malloc() is used to allocate memory from heap to your array of memory. 

---

In Java, all arrays are allocated dynamically.

public class Foo {
	static int a;
	static int b[] = new int[10];

The compiler allocates memory as soon as this line executes: int b[] = new int[10];

The compiler does not know the address of a dynamic array. BUT it does know the address of b and b contains the address/reference of the aray. b stores a reference to the array. 

--- 

Instance variable are also called non-static variable. Static variables do not differ with the object. Non-static (Instance) variable can differ with the object. An example could be that you have class Dog and an instance variable could be age because age differs with the instance of dog. You do not need to declare "static" when declaring an instance variable.

int a <-- because the word "static" isn't declared, this is an instance variable
static int b <-- because the word "static" is here, this is a static variable

A static variable example could be numberOfLegs because all instance of dogs will have 4 legs no matter the instance. 

Local variable are variables declared inside a method. As long as the method is running, the local variable exists, as soon as the method is done, the local variable will have been deallocated.

---

Memory and types of variables:

Static Variables: The compiler knows exactly where in memory a static variable is located.

Instance Variables: Instance variables are dynamic variables (to be dynamic means that its address and values is only known during runtime). Although the compiler may not know the address of an instance variable, it does know the object that contains it. And if the compiler knows the address of the object, it can perform an offset to find the instance variable. 

---

Deallocation:

Deallocation is important for efficient use of memory. 

In C, free is a method that frees the memory immediately
.
A dangling pointer is a pointer that points to an address that has been freed. This is dangerous because a variable could still be pointing to the freed memory. The solution is that after you freed an address, you should re initialize the variable. 

In Java, objects are deallocated implicitly. A garbage collector runs periodically to deallocate unreachable objects. Hence, there is no worry of a dangling pointer. 

In Java, "new" allocates memory for an object in a heap space
Dog d1 = new Dog("Joey")
Dog d2 = new Dog("Snoopy")

Next, if we write:
d2 = new("Draco")
System.out.println(d2)

This will print out "Draco" and not "Snoopy" because a garbage collector went and freed d2 from having a value of Snoopy.

Garbage Collection: automatically frees memory. 

Memory leak happens when the garbage collector fails to deallocate memory.









